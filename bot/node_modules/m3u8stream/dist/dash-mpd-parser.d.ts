/// <reference types="node" />
import { Writable } from 'stream';
declare const _default: {
    new (targetID?: string): {
        _parser: Writable;
        _write(chunk: Buffer, encoding: string, callback: () => void): void;
        readonly writable: boolean;
        readonly writableFinished: boolean;
        readonly writableHighWaterMark: number;
        readonly writableLength: number;
        _writev?(chunks: {
            chunk: any;
            encoding: string;
        }[], callback: (error?: Error) => void): void;
        _destroy(error: Error, callback: (error?: Error) => void): void;
        _final(callback: (error?: Error) => void): void;
        write(chunk: any, cb?: (error: Error) => void): boolean;
        write(chunk: any, encoding: string, cb?: (error: Error) => void): boolean;
        setDefaultEncoding(encoding: string): any;
        end(cb?: () => void): void;
        end(chunk: any, cb?: () => void): void;
        end(chunk: any, encoding: string, cb?: () => void): void;
        cork(): void;
        uncork(): void;
        destroy(error?: Error): void;
        addListener(event: "close", listener: () => void): any;
        addListener(event: "drain", listener: () => void): any;
        addListener(event: "error", listener: (err: Error) => void): any;
        addListener(event: "finish", listener: () => void): any;
        addListener(event: "pipe", listener: (src: import("stream").Readable) => void): any;
        addListener(event: "unpipe", listener: (src: import("stream").Readable) => void): any;
        addListener(event: string | symbol, listener: (...args: any[]) => void): any;
        emit(event: "close"): boolean;
        emit(event: "drain"): boolean;
        emit(event: "error", err: Error): boolean;
        emit(event: "finish"): boolean;
        emit(event: "pipe", src: import("stream").Readable): boolean;
        emit(event: "unpipe", src: import("stream").Readable): boolean;
        emit(event: string | symbol, ...args: any[]): boolean;
        on(event: "close", listener: () => void): any;
        on(event: "drain", listener: () => void): any;
        on(event: "error", listener: (err: Error) => void): any;
        on(event: "finish", listener: () => void): any;
        on(event: "pipe", listener: (src: import("stream").Readable) => void): any;
        on(event: "unpipe", listener: (src: import("stream").Readable) => void): any;
        on(event: string | symbol, listener: (...args: any[]) => void): any;
        once(event: "close", listener: () => void): any;
        once(event: "drain", listener: () => void): any;
        once(event: "error", listener: (err: Error) => void): any;
        once(event: "finish", listener: () => void): any;
        once(event: "pipe", listener: (src: import("stream").Readable) => void): any;
        once(event: "unpipe", listener: (src: import("stream").Readable) => void): any;
        once(event: string | symbol, listener: (...args: any[]) => void): any;
        prependListener(event: "close", listener: () => void): any;
        prependListener(event: "drain", listener: () => void): any;
        prependListener(event: "error", listener: (err: Error) => void): any;
        prependListener(event: "finish", listener: () => void): any;
        prependListener(event: "pipe", listener: (src: import("stream").Readable) => void): any;
        prependListener(event: "unpipe", listener: (src: import("stream").Readable) => void): any;
        prependListener(event: string | symbol, listener: (...args: any[]) => void): any;
        prependOnceListener(event: "close", listener: () => void): any;
        prependOnceListener(event: "drain", listener: () => void): any;
        prependOnceListener(event: "error", listener: (err: Error) => void): any;
        prependOnceListener(event: "finish", listener: () => void): any;
        prependOnceListener(event: "pipe", listener: (src: import("stream").Readable) => void): any;
        prependOnceListener(event: "unpipe", listener: (src: import("stream").Readable) => void): any;
        prependOnceListener(event: string | symbol, listener: (...args: any[]) => void): any;
        removeListener(event: "close", listener: () => void): any;
        removeListener(event: "drain", listener: () => void): any;
        removeListener(event: "error", listener: (err: Error) => void): any;
        removeListener(event: "finish", listener: () => void): any;
        removeListener(event: "pipe", listener: (src: import("stream").Readable) => void): any;
        removeListener(event: "unpipe", listener: (src: import("stream").Readable) => void): any;
        removeListener(event: string | symbol, listener: (...args: any[]) => void): any;
        pipe<T extends NodeJS.WritableStream>(destination: T, options?: {
            end?: boolean;
        }): T;
        off(event: string | symbol, listener: (...args: any[]) => void): any;
        removeAllListeners(event?: string | symbol): any;
        setMaxListeners(n: number): any;
        getMaxListeners(): number;
        listeners(event: string | symbol): Function[];
        rawListeners(event: string | symbol): Function[];
        eventNames(): (string | symbol)[];
        listenerCount(type: string | symbol): number;
    };
    finished: typeof import("stream").finished;
    pipeline: typeof import("stream").pipeline;
    Stream: typeof import("stream").Stream;
    Readable: typeof import("stream").Readable;
    Writable: typeof Writable;
    Duplex: typeof import("stream").Duplex;
    Transform: typeof import("stream").Transform;
    PassThrough: typeof import("stream").PassThrough;
    listenerCount(emitter: import("events").EventEmitter, event: string | symbol): number;
    defaultMaxListeners: number;
    once(emitter: import("events").EventEmitter, event: string | symbol): Promise<any[]>;
    EventEmitter: typeof import("events").EventEmitter;
};
/**
 * A wrapper around sax that emits segments.
 */
export = _default;
